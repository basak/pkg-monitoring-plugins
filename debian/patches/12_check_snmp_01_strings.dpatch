#! /bin/sh /usr/share/dpatch/dpatch-run
## 12_check_snmp_01_strings.dpatch by
## Thomas Guyot-Sionnest <dermoth@aei.ca>
##
## From 4d1cd3a7dc2754f4fb69f2a80ce4e2a027f180a3 Mon Sep 17 00:00:00 2001
## From: nagios <nagios@opsviewdev32.(none)>
## Date: Mon, 15 Nov 2010 15:43:41 +0000
## Subject: [PATCH 1/4] check_snmp now considers strings returned by SNMP that contain just numbers (according to strtod) to be a numeric value for threshold and performance data
## (Debian Bug #607736)
##
## DP: Now considers strings returned by SNMP that contain just numbers

@DPATCH@

diff --git a/plugins/check_snmp.c b/plugins/check_snmp.c
index f32a26e..9d91942 100644
--- a/plugins/check_snmp.c
+++ b/plugins/check_snmp.c
@@ -160,6 +160,7 @@ main (int argc, char **argv)
 	char *outbuff;
 	char *ptr = NULL;
 	char *show = NULL;
+	char *endptr = NULL;
 	char *th_warn=NULL;
 	char *th_crit=NULL;
 	char type[8] = "";
@@ -395,6 +396,19 @@ main (int argc, char **argv)
 				}
 			}
 
+			/* Allow numeric conversion if whole string is a number. Make concession for strings with " at beginning or end */
+			/* This duplicates the conversion a bit later, but is cleaner to separate out the checking against the conversion */
+			ptr = show;
+			if (*ptr == '"')
+				ptr++;
+			if (*ptr != '\0' ) {
+				strtod( ptr, &endptr );
+				if (*endptr == '"')
+					endptr++;
+				if (*endptr == '\0')
+					is_numeric=1;
+			}
+
 		}
 		else if (strstr (response, "Timeticks: "))
 			show = strstr (response, "Timeticks: ");
diff --git a/plugins/tests/check_snmp.t b/plugins/tests/check_snmp.t
index e7ad192..08348d2 100755
--- a/plugins/tests/check_snmp.t
+++ b/plugins/tests/check_snmp.t
@@ -51,7 +51,7 @@ if ($ARGV[0] && $ARGV[0] eq "-d") {
 	}
 }
 
-my $tests = 33;
+my $tests = 41;
 if (-x "./check_snmp") {
 	plan tests => $tests;
 } else {
@@ -170,5 +170,20 @@ $res = NPTest->testCmd( "./check_snmp -H 127.0.0.1 -C public -p $port_snmp -o .1
 is($res->return_code, 0, "OK as string doesn't match but inverted" );
 is($res->output, 'SNMP OK - "stringtests" | ', "OK as inverted string no match" );
 
+$res = NPTest->testCmd( "./check_snmp -H 127.0.0.1 -C public -p $port_snmp -o .1.3.6.1.4.1.8072.3.2.67.12" );
+is($res->return_code, 0, "Numeric in string test" );
+is($res->output, 'SNMP OK - 3.5 | iso.3.6.1.4.1.8072.3.2.67.12=3.5 ', "Check seen as numeric" );
+
+$res = NPTest->testCmd( "./check_snmp -H 127.0.0.1 -C public -p $port_snmp -o .1.3.6.1.4.1.8072.3.2.67.12 -w 4:5" );
+is($res->return_code, 1, "Numeric in string test" );
+is($res->output, 'SNMP WARNING - *3.5* | iso.3.6.1.4.1.8072.3.2.67.12=3.5 ', "WARNING threshold checks for string masquerading as number" );
+
+$res = NPTest->testCmd( "./check_snmp -H 127.0.0.1 -C public -p $port_snmp -o .1.3.6.1.4.1.8072.3.2.67.13" );
+is($res->return_code, 0, "Not really numeric test" );
+is($res->output, 'SNMP OK - "87.4startswithnumberbutshouldbestring" | ', "Check string with numeric start is still string" );
+
+$res = NPTest->testCmd( "./check_snmp -H 127.0.0.1 -C public -p $port_snmp -o .1.3.6.1.4.1.8072.3.2.67.14" );
+is($res->return_code, 0, "Not really numeric test (trying best to fool it)" );
+is($res->output, 'SNMP OK - "555\"I said\"" | ', "Check string with a double quote following is still a string (looks like the perl routine will always escape though)" );
 
 
diff --git a/plugins/tests/check_snmp_agent.pl b/plugins/tests/check_snmp_agent.pl
index 8784ab1..2ad8516 100644
--- a/plugins/tests/check_snmp_agent.pl
+++ b/plugins/tests/check_snmp_agent.pl
@@ -33,9 +33,9 @@ ends with with this: C:\\';
 my $multilin5 = 'And now have fun with with this: "C:\\"
 because we\'re not done yet!';
 
-my @fields = (ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_UNSIGNED, ASN_UNSIGNED, ASN_COUNTER, ASN_COUNTER64, ASN_UNSIGNED, ASN_COUNTER, ASN_OCTET_STR);
-my @values = ($multiline, $multilin2, $multilin3, $multilin4, $multilin5, 4294965296, 1000, 4294965296, uint64("18446744073709351616"), int(rand(2**32)), 64000, "stringtests");
-my @incrts = (undef, undef, undef, undef, undef, 1000, -500, 1000, 100000, undef, 666, undef);
+my @fields = (ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_UNSIGNED, ASN_UNSIGNED, ASN_COUNTER, ASN_COUNTER64, ASN_UNSIGNED, ASN_COUNTER, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR, ASN_OCTET_STR );
+my @values = ($multiline, $multilin2, $multilin3, $multilin4, $multilin5, 4294965296, 1000, 4294965296, uint64("18446744073709351616"), int(rand(2**32)), 64000, "stringtests", "3.5", "87.4startswithnumberbutshouldbestring", '555"I said"' );
+my @incrts = (undef, undef, undef, undef, undef, 1000, -500, 1000, 100000, undef, 666, undef, undef, undef, undef );
 
 # Number of elements in our OID
 my $oidelts;
-- 
1.7.3.2

